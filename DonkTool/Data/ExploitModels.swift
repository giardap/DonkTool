//
//  ExploitModels.swift
//  DonkTool
//
//  Exploit framework models for CVE and Metasploit integration
//

import Foundation

// MARK: - CVE Models

struct CVEEntry: Codable, Identifiable {
    let id: String // CVE-YYYY-NNNN
    let description: String
    let cvssScore: Double
    let severity: Severity
    let publishedDate: Date
    let lastModified: Date
    let affectedProducts: [String]
    let exploitAvailable: Bool
    let exploitMaturity: ExploitMaturity
    let references: [String]
    let cweId: String?
    
    enum Severity: String, CaseIterable, Codable {
        case critical = "Critical"
        case high = "High"
        case medium = "Medium"
        case low = "Low"
        case none = "None"
        
        var color: Color {
            switch self {
            case .critical: return .red
            case .high: return .orange
            case .medium: return .yellow
            case .low: return .green
            case .none: return .gray
            }
        }
        
        var priority: Int {
            switch self {
            case .critical: return 5
            case .high: return 4
            case .medium: return 3
            case .low: return 2
            case .none: return 1
            }
        }
    }
}

enum ExploitMaturity: String, CaseIterable, Codable {
    case unproven = "Unproven"
    case proofOfConcept = "Proof of Concept"
    case functional = "Functional"
    case high = "High"
    case weaponized = "Weaponized"
    
    var reliability: Double {
        switch self {
        case .unproven: return 0.1
        case .proofOfConcept: return 0.3
        case .functional: return 0.6
        case .high: return 0.8
        case .weaponized: return 0.95
        }
    }
}

// MARK: - Exploit Database Models

enum ExploitType: String, CaseIterable, Codable {
    case remote = "Remote"
    case local = "Local"
    case webApp = "Web Application"
    case dos = "Denial of Service"
    case clientSide = "Client Side"
    case privilege = "Privilege Escalation"
    case codeExecution = "Code Execution"
    case sqlInjection = "SQL Injection"
    case bufferOverflow = "Buffer Overflow"
}

enum ExploitDifficulty: String, CaseIterable, Codable {
    case trivial = "Trivial"
    case easy = "Easy"
    case medium = "Medium"
    case hard = "Hard"
    case expert = "Expert"
    
    var skillLevel: Int {
        switch self {
        case .trivial: return 1
        case .easy: return 2
        case .medium: return 3
        case .hard: return 4
        case .expert: return 5
        }
    }
}

// ExploitEntry is now defined in SearchSploitManager.swift with SearchSploit integration

// MARK: - Metasploit Integration Models

struct MetasploitModule: Codable, Identifiable {
    let id: UUID
    let name: String
    let fullName: String
    let cveId: String?
    let description: String
    let rank: ExploitRank
    let targets: [String]
    let payloads: [String]
    let difficulty: ExploitDifficulty
    let category: ModuleCategory
    let lastUpdate: Date
    let isReliable: Bool
    
    init(name: String, fullName: String, cveId: String?, description: String, rank: ExploitRank, targets: [String], payloads: [String], difficulty: ExploitDifficulty, category: ModuleCategory, lastUpdate: Date, isReliable: Bool) {
        self.id = UUID()
        self.name = name
        self.fullName = fullName
        self.cveId = cveId
        self.description = description
        self.rank = rank
        self.targets = targets
        self.payloads = payloads
        self.difficulty = difficulty
        self.category = category
        self.lastUpdate = lastUpdate
        self.isReliable = isReliable
    }
    
    enum ExploitRank: String, CaseIterable, Codable {
        case excellent = "Excellent"
        case great = "Great" 
        case good = "Good"
        case normal = "Normal"
        case average = "Average"
        case low = "Low"
        case manual = "Manual"
        
        var score: Int {
            switch self {
            case .excellent: return 700
            case .great: return 600
            case .good: return 500
            case .normal: return 400
            case .average: return 300
            case .low: return 200
            case .manual: return 100
            }
        }
        
        var color: Color {
            switch self {
            case .excellent, .great: return .green
            case .good, .normal: return .yellow
            case .average, .low: return .orange
            case .manual: return .red
            }
        }
    }
    
    enum ModuleCategory: String, CaseIterable, Codable {
        case exploit = "Exploit"
        case auxiliary = "Auxiliary"
        case post = "Post-Exploitation"
        case payload = "Payload"
        case encoder = "Encoder"
        case nop = "NOP Generator"
        case evasion = "Evasion"
    }
}

// MARK: - Payload Generation Models

struct PayloadConfiguration: Codable {
    let type: PayloadType
    let lhost: String
    let lport: Int
    let format: String
    let encoder: String?
    let iterations: Int
    let badChars: String?
    let platform: String
    let architecture: String
    
    enum PayloadType: String, CaseIterable, Codable {
        case meterpreter = "windows/meterpreter/reverse_tcp"
        case shell = "windows/shell/reverse_tcp"
        case linuxMeterpreter = "linux/x86/meterpreter/reverse_tcp"
        case linuxShell = "linux/x86/shell/reverse_tcp"
        case macMeterpreter = "osx/x86/shell_reverse_tcp"
        case webShell = "php/meterpreter/reverse_tcp"
        case powershell = "windows/powershell_reverse_tcp"
        case pythonShell = "python/shell_reverse_tcp"
        
        var description: String {
            switch self {
            case .meterpreter: return "Windows Meterpreter (Reverse TCP)"
            case .shell: return "Windows Command Shell (Reverse TCP)"
            case .linuxMeterpreter: return "Linux Meterpreter (Reverse TCP)"
            case .linuxShell: return "Linux Shell (Reverse TCP)"
            case .macMeterpreter: return "macOS Shell (Reverse TCP)"
            case .webShell: return "PHP Web Shell (Reverse TCP)"
            case .powershell: return "PowerShell (Reverse TCP)"
            case .pythonShell: return "Python Shell (Reverse TCP)"
            }
        }
    }
}

struct PayloadResult: Codable {
    let success: Bool
    let payloadPath: String?
    let size: Int?
    let checksum: String?
    let generationTime: Date
    let configuration: PayloadConfiguration
    let errorMessage: String?
}

// MARK: - Post-Exploitation Models

enum PostExploitModule: String, CaseIterable, Codable {
    case privilegeEscalation = "Privilege Escalation"
    case lateralMovement = "Lateral Movement"
    case dataExfiltration = "Data Exfiltration"
    case persistence = "Persistence"
    case coverTracks = "Cover Tracks"
    case reconnaissance = "Reconnaissance"
    case credentialHarvesting = "Credential Harvesting"
    
    var icon: String {
        switch self {
        case .privilegeEscalation: return "crown.fill"
        case .lateralMovement: return "arrow.triangle.swap"
        case .dataExfiltration: return "square.and.arrow.up"
        case .persistence: return "lock.fill"
        case .coverTracks: return "eye.slash"
        case .reconnaissance: return "binoculars"
        case .credentialHarvesting: return "key.fill"
        }
    }
}

struct PostExploitAction: Codable, Identifiable {
    let id: UUID
    let module: PostExploitModule
    let command: String
    let description: String
    let riskLevel: RiskLevel
    let requirements: [String]
    let expectedOutput: String
    let stealthLevel: StealthLevel
    
    init(module: PostExploitModule, command: String, description: String, riskLevel: RiskLevel, requirements: [String], expectedOutput: String, stealthLevel: StealthLevel) {
        self.id = UUID()
        self.module = module
        self.command = command
        self.description = description
        self.riskLevel = riskLevel
        self.requirements = requirements
        self.expectedOutput = expectedOutput
        self.stealthLevel = stealthLevel
    }
    
    enum RiskLevel: String, CaseIterable, Codable {
        case minimal = "Minimal"
        case low = "Low"
        case medium = "Medium"
        case high = "High"
        case critical = "Critical"
        
        var color: Color {
            switch self {
            case .minimal: return .green
            case .low: return .mint
            case .medium: return .yellow
            case .high: return .orange
            case .critical: return .red
            }
        }
    }
    
    enum StealthLevel: String, CaseIterable, Codable {
        case silent = "Silent"
        case low = "Low Noise"
        case medium = "Medium Noise"
        case high = "High Noise"
        case loud = "Very Loud"
        
        var description: String {
            switch self {
            case .silent: return "No logs or alerts expected"
            case .low: return "Minimal logging, unlikely to trigger alerts"
            case .medium: return "Some logging, may trigger minor alerts"
            case .high: return "Significant logging, likely to trigger alerts"
            case .loud: return "Heavy logging, will definitely trigger alerts"
            }
        }
    }
}

// MARK: - CVSS Scoring Models

struct CVSSScore: Codable {
    let baseScore: Double
    let temporalScore: Double?
    let environmentalScore: Double?
    let vector: String
    let metrics: CVSSMetrics
    
    var severity: CVEEntry.Severity {
        switch baseScore {
        case 9.0...10.0: return .critical
        case 7.0..<9.0: return .high
        case 4.0..<7.0: return .medium
        case 0.1..<4.0: return .low
        default: return .none
        }
    }
}

struct CVSSMetrics: Codable {
    // Base Metrics
    let attackVector: AttackVector
    let attackComplexity: AttackComplexity
    let privilegesRequired: PrivilegesRequired
    let userInteraction: UserInteraction
    let scope: Scope
    let confidentialityImpact: Impact
    let integrityImpact: Impact
    let availabilityImpact: Impact
    
    // Temporal Metrics (optional)
    let exploitCodeMaturity: ExploitCodeMaturity?
    let remediationLevel: RemediationLevel?
    let reportConfidence: ReportConfidence?
    
    enum AttackVector: String, CaseIterable, Codable {
        case network = "Network"
        case adjacent = "Adjacent Network"
        case local = "Local"
        case physical = "Physical"
    }
    
    enum AttackComplexity: String, CaseIterable, Codable {
        case low = "Low"
        case high = "High"
    }
    
    enum PrivilegesRequired: String, CaseIterable, Codable {
        case none = "None"
        case low = "Low"
        case high = "High"
    }
    
    enum UserInteraction: String, CaseIterable, Codable {
        case none = "None"
        case required = "Required"
    }
    
    enum Scope: String, CaseIterable, Codable {
        case unchanged = "Unchanged"
        case changed = "Changed"
    }
    
    enum Impact: String, CaseIterable, Codable {
        case none = "None"
        case low = "Low"
        case high = "High"
    }
    
    enum ExploitCodeMaturity: String, CaseIterable, Codable {
        case notDefined = "Not Defined"
        case unproven = "Unproven"
        case proofOfConcept = "Proof of Concept"
        case functional = "Functional"
        case high = "High"
    }
    
    enum RemediationLevel: String, CaseIterable, Codable {
        case notDefined = "Not Defined"
        case officialFix = "Official Fix"
        case temporaryFix = "Temporary Fix"
        case workaround = "Workaround"
        case unavailable = "Unavailable"
    }
    
    enum ReportConfidence: String, CaseIterable, Codable {
        case notDefined = "Not Defined"
        case unknown = "Unknown"
        case reasonable = "Reasonable"
        case confirmed = "Confirmed"
    }
}

// MARK: - Extension for SwiftUI Color
import SwiftUI

extension Color {
    static let mint = Color(red: 0.0, green: 0.8, blue: 0.6)
}