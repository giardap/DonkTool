//
//  ExploitDatabase.swift
//  DonkTool
//
//  CVE and Exploit Database Management System
//

import Foundation
import SwiftUI

@MainActor
class ExploitDatabase: ObservableObject {
    static let shared = ExploitDatabase()
    
    @Published var cveEntries: [CVEEntry] = []
    @Published var exploitEntries: [ExploitEntry] = []
    @Published var metasploitModules: [MetasploitModule] = []
    @Published var isUpdating = false
    @Published var lastUpdate: Date?
    @Published var updateProgress: Double = 0.0
    
    private let nvdApiUrl = "https://services.nvd.nist.gov/rest/json/cves/2.0"
    private let exploitDbUrl = "https://www.exploit-db.com"
    private let cacheDirectory: URL
    
    private init() {
        // Create cache directory
        let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
        cacheDirectory = documentsPath.appendingPathComponent("ExploitDatabase")
        
        do {
            try FileManager.default.createDirectory(at: cacheDirectory, withIntermediateDirectories: true)
        } catch {
            print("Failed to create cache directory: \(error)")
        }
        
        loadCachedData()
    }
    
    // MARK: - CVE Database Functions
    
    func updateCVEDatabase() async {
        isUpdating = true
        updateProgress = 0.0
        
        do {
            print("📡 Updating CVE database from NVD...")
            
            // Get recent CVEs (last 30 days)
            let thirtyDaysAgo = Calendar.current.date(byAdding: .day, value: -30, to: Date()) ?? Date()
            let dateFormatter = DateFormatter()
            dateFormatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"
            
            let startDate = dateFormatter.string(from: thirtyDaysAgo)
            let endDate = dateFormatter.string(from: Date())
            
            let urlString = "\(nvdApiUrl)?lastModStartDate=\(startDate)&lastModEndDate=\(endDate)"
            guard let url = URL(string: urlString) else {
                throw ExploitDatabaseError.invalidURL
            }
            
            updateProgress = 0.3
            
            var request = URLRequest(url: url)
            request.setValue("application/json", forHTTPHeaderField: "Accept")
            request.timeoutInterval = 30
            
            let (data, response) = try await URLSession.shared.data(for: request)
            
            guard let httpResponse = response as? HTTPURLResponse,
                  httpResponse.statusCode == 200 else {
                throw ExploitDatabaseError.networkError
            }
            
            updateProgress = 0.6
            
            let nvdResponse = try JSONDecoder().decode(NVDResponse.self, from: data)
            let newCVEs = nvdResponse.vulnerabilities.compactMap { convertNVDToCVE($0) }
            
            updateProgress = 0.8
            
            // Merge with existing CVEs
            var updatedCVEs = cveEntries
            for newCVE in newCVEs {
                if let index = updatedCVEs.firstIndex(where: { $0.id == newCVE.id }) {
                    updatedCVEs[index] = newCVE
                } else {
                    updatedCVEs.append(newCVE)
                }
            }
            
            cveEntries = updatedCVEs.sorted { $0.publishedDate > $1.publishedDate }
            
            updateProgress = 1.0
            lastUpdate = Date()
            
            // Cache the updated data
            saveCachedData()
            
            print("✅ CVE database updated: \(newCVEs.count) new/updated entries")
            
        } catch {
            print("❌ Failed to update CVE database: \(error)")
        }
        
        isUpdating = false
    }
    
    func searchCVEs(query: String) -> [CVEEntry] {
        let lowercaseQuery = query.lowercased()
        return cveEntries.filter { cve in
            cve.id.lowercased().contains(lowercaseQuery) ||
            cve.description.lowercased().contains(lowercaseQuery) ||
            cve.affectedProducts.joined().lowercased().contains(lowercaseQuery)
        }
    }
    
    func searchExploits(cve: String) async -> [ExploitEntry] {
        return exploitEntries.filter { exploit in
            exploit.cveId == cve ||
            exploit.title.localizedCaseInsensitiveContains(cve) ||
            exploit.tags.contains { $0.localizedCaseInsensitiveContains(cve) }
        }
    }
    
    // MARK: - Searchsploit Integration
    
    func runSearchsploit(query: String) async -> [ExploitEntry] {
        guard ToolDetection.shared.isToolInstalled("searchsploit") else {
            print("❌ searchsploit not installed")
            return []
        }
        
        let process = Process()
        let pipe = Pipe()
        
        // Find searchsploit path
        let searchsploitPaths = [
            "/usr/local/bin/searchsploit",
            "/opt/homebrew/bin/searchsploit",
            "/usr/bin/searchsploit"
        ]
        
        var executablePath: String?
        for path in searchsploitPaths {
            if FileManager.default.fileExists(atPath: path) {
                executablePath = path
                break
            }
        }
        
        guard let execPath = executablePath else {
            print("❌ searchsploit executable not found")
            return []
        }
        
        process.executableURL = URL(fileURLWithPath: execPath)
        process.arguments = [query, "--json", "--colour", "never"]
        process.standardOutput = pipe
        
        do {
            try process.run()
            process.waitUntilExit()
            
            let data = pipe.fileHandleForReading.readDataToEndOfFile()
            let output = String(data: data, encoding: .utf8) ?? ""
            
            return parseSearchsploitOutput(output)
            
        } catch {
            print("❌ Failed to run searchsploit: \(error)")
            return []
        }
    }
    
    // MARK: - Metasploit Integration
    
    func updateMetasploitModules() async {
        guard ToolDetection.shared.isToolInstalled("msfconsole") else {
            print("❌ Metasploit not installed")
            return
        }
        
        isUpdating = true
        updateProgress = 0.0
        
        print("🔫 Updating Metasploit module database...")
        
        let process = Process()
        let pipe = Pipe()
        
        process.executableURL = URL(fileURLWithPath: "/usr/local/bin/msfconsole")
        process.arguments = ["-q", "-x", "search -h; exit"]
        process.standardOutput = pipe
        
        do {
            try process.run()
            updateProgress = 0.5
            
            process.waitUntilExit()
            updateProgress = 1.0
            
            // For now, load sample Metasploit modules
            loadSampleMetasploitModules()
            
            print("✅ Metasploit modules updated")
            
        } catch {
            print("❌ Failed to update Metasploit modules: \(error)")
        }
        
        isUpdating = false
    }
    
    func searchMetasploitModules(query: String) -> [MetasploitModule] {
        let lowercaseQuery = query.lowercased()
        return metasploitModules.filter { module in
            module.name.lowercased().contains(lowercaseQuery) ||
            module.description.lowercased().contains(lowercaseQuery) ||
            module.cveId?.lowercased().contains(lowercaseQuery) == true
        }
    }
    
    // MARK: - Exploit Code Download
    
    func downloadExploit(edbId: String) async -> ExploitCode? {
        let exploitUrl = "https://www.exploit-db.com/download/\(edbId)"
        
        guard let url = URL(string: exploitUrl) else {
            return nil
        }
        
        do {
            let (data, _) = try await URLSession.shared.data(from: url)
            let code = String(data: data, encoding: .utf8) ?? ""
            
            return ExploitCode(
                id: edbId,
                code: code,
                downloadDate: Date(),
                size: data.count
            )
        } catch {
            print("❌ Failed to download exploit: \(error)")
            return nil
        }
    }
    
    // MARK: - CVSS Calculation
    
    func calculateCVSSScore(metrics: CVSSMetrics) -> CVSSScore {
        // CVSS 3.1 Base Score Calculation
        
        // Impact Score Calculation
        let iscBase = 1 - ((1 - confidentialityScore(metrics.confidentialityImpact)) *
                          (1 - integrityScore(metrics.integrityImpact)) *
                          (1 - availabilityScore(metrics.availabilityImpact)))
        
        let impact: Double
        if metrics.scope == .unchanged {
            impact = 6.42 * iscBase
        } else {
            impact = 7.52 * (iscBase - 0.029) - 3.25 * pow(iscBase - 0.02, 15)
        }
        
        // Exploitability Score
        let exploitability = 8.22 * attackVectorScore(metrics.attackVector) *
                           attackComplexityScore(metrics.attackComplexity) *
                           privilegesRequiredScore(metrics.privilegesRequired, scope: metrics.scope) *
                           userInteractionScore(metrics.userInteraction)
        
        // Base Score
        let baseScore: Double
        if impact <= 0 {
            baseScore = 0
        } else if metrics.scope == .unchanged {
            baseScore = min(impact + exploitability, 10.0)
        } else {
            baseScore = min(1.08 * (impact + exploitability), 10.0)
        }
        
        let roundedBaseScore = ceil(baseScore * 10) / 10
        
        // Calculate temporal score if temporal metrics are provided
        var temporalScore: Double?
        if let exploitCodeMaturity = metrics.exploitCodeMaturity,
           let remediationLevel = metrics.remediationLevel,
           let reportConfidence = metrics.reportConfidence {
            
            let temporal = roundedBaseScore *
                          exploitCodeMaturityScore(exploitCodeMaturity) *
                          remediationLevelScore(remediationLevel) *
                          reportConfidenceScore(reportConfidence)
            temporalScore = ceil(temporal * 10) / 10
        }
        
        return CVSSScore(
            baseScore: roundedBaseScore,
            temporalScore: temporalScore,
            environmentalScore: nil,
            vector: generateCVSSVector(metrics),
            metrics: metrics
        )
    }
    
    // MARK: - Private Helper Methods
    
    private func loadCachedData() {
        // Load cached CVE data
        let cveFile = cacheDirectory.appendingPathComponent("cve_cache.json")
        if let cveData = try? Data(contentsOf: cveFile),
           let cachedCVEs = try? JSONDecoder().decode([CVEEntry].self, from: cveData) {
            cveEntries = cachedCVEs
        }
        
        // Load cached exploit data
        let exploitFile = cacheDirectory.appendingPathComponent("exploit_cache.json")
        if let exploitData = try? Data(contentsOf: exploitFile),
           let cachedExploits = try? JSONDecoder().decode([ExploitEntry].self, from: exploitData) {
            exploitEntries = cachedExploits
        }
        
        // Load sample data if cache is empty
        if cveEntries.isEmpty {
            loadSampleCVEs()
        }
        if exploitEntries.isEmpty {
            loadSampleExploits()
        }
        if metasploitModules.isEmpty {
            loadSampleMetasploitModules()
        }
    }
    
    private func saveCachedData() {
        // Save CVE data
        let cveFile = cacheDirectory.appendingPathComponent("cve_cache.json")
        if let cveData = try? JSONEncoder().encode(cveEntries) {
            try? cveData.write(to: cveFile)
        }
        
        // Save exploit data
        let exploitFile = cacheDirectory.appendingPathComponent("exploit_cache.json")
        if let exploitData = try? JSONEncoder().encode(exploitEntries) {
            try? exploitData.write(to: exploitFile)
        }
    }
    
    private func convertNVDToCVE(_ nvdItem: NVDVulnerability) -> CVEEntry? {
        guard let cveData = nvdItem.cve else { return nil }
        
        let description = cveData.descriptions.first?.value ?? "No description available"
        let publishedDate = ISO8601DateFormatter().date(from: nvdItem.publishedDate) ?? Date()
        let lastModified = ISO8601DateFormatter().date(from: nvdItem.lastModifiedDate) ?? Date()
        
        // Extract CVSS score
        let cvssScore = nvdItem.metrics?.cvssMetricV31?.first?.cvssData.baseScore ?? 0.0
        
        // Determine severity
        let severity: CVEEntry.Severity
        switch cvssScore {
        case 9.0...10.0: severity = .critical
        case 7.0..<9.0: severity = .high
        case 4.0..<7.0: severity = .medium
        case 0.1..<4.0: severity = .low
        default: severity = .none
        }
        
        return CVEEntry(
            id: cveData.id,
            description: description,
            cvssScore: cvssScore,
            severity: severity,
            publishedDate: publishedDate,
            lastModified: lastModified,
            affectedProducts: extractAffectedProducts(from: nvdItem),
            exploitAvailable: false, // Would need to check exploit databases
            exploitMaturity: .unproven,
            references: cveData.references?.map { $0.url } ?? [],
            cweId: nvdItem.cve?.weaknesses?.first?.description?.first?.value
        )
    }
    
    private func extractAffectedProducts(from nvdItem: NVDVulnerability) -> [String] {
        guard let configurations = nvdItem.configurations else { return [] }
        
        var products: [String] = []
        for config in configurations {
            for node in config.nodes {
                for cpeMatch in node.cpeMatch {
                    if let criteria = cpeMatch.criteria {
                        // Parse CPE string to extract product name
                        let components = criteria.split(separator: ":")
                        if components.count >= 5 {
                            let vendor = String(components[3])
                            let product = String(components[4])
                            products.append("\(vendor) \(product)")
                        }
                    }
                }
            }
        }
        
        return Array(Set(products)) // Remove duplicates
    }
    
    private func parseSearchsploitOutput(_ output: String) -> [ExploitEntry] {
        // Parse JSON output from searchsploit
        guard let data = output.data(using: .utf8),
              let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
              let exploits = json["RESULTS_EXPLOIT"] as? [[String: Any]] else {
            return []
        }
        
        return exploits.compactMap { exploitData in
            guard let title = exploitData["Title"] as? String,
                  let edbId = exploitData["EDB-ID"] as? String,
                  let _ = exploitData["Date"] as? String,
                  let author = exploitData["Author"] as? String,
                  let platform = exploitData["Platform"] as? String,
                  let type = exploitData["Type"] as? String else {
                return nil
            }
            
            return ExploitEntry(
                id: edbId,
                cveId: extractCVEFromTitle(title),
                title: title,
                author: author,
                platform: [platform],
                type: mapExploitType(type),
                code: nil,
                verifiedWorking: false,
                lastTested: nil,
                difficulty: .medium,
                tags: [type, platform],
                references: []
            )
        }
    }
    
    private func extractCVEFromTitle(_ title: String) -> String? {
        let pattern = "CVE-\\d{4}-\\d{4,7}"
        let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive)
        let range = NSRange(title.startIndex..., in: title)
        
        if let match = regex?.firstMatch(in: title, options: [], range: range) {
            return String(title[Range(match.range, in: title)!])
        }
        return nil
    }
    
    private func mapExploitType(_ type: String) -> ExploitType {
        switch type.lowercased() {
        case "remote": return .remote
        case "local": return .local
        case "web": return .webApp
        case "dos": return .dos
        case "client": return .clientSide
        default: return .remote
        }
    }
    
    // MARK: - Sample Data Loaders
    
    private func loadSampleCVEs() {
        cveEntries = [
            CVEEntry(
                id: "CVE-2024-1234",
                description: "Remote code execution vulnerability in Example Software",
                cvssScore: 9.8,
                severity: .critical,
                publishedDate: Date(),
                lastModified: Date(),
                affectedProducts: ["Example Software 1.0", "Example Software 1.1"],
                exploitAvailable: true,
                exploitMaturity: .functional,
                references: ["https://example.com/advisory"],
                cweId: "CWE-78"
            ),
            CVEEntry(
                id: "CVE-2024-5678",
                description: "SQL injection vulnerability in Web Application",
                cvssScore: 7.5,
                severity: .high,
                publishedDate: Calendar.current.date(byAdding: .day, value: -1, to: Date()) ?? Date(),
                lastModified: Calendar.current.date(byAdding: .day, value: -1, to: Date()) ?? Date(),
                affectedProducts: ["Web App 2.0"],
                exploitAvailable: true,
                exploitMaturity: .proofOfConcept,
                references: ["https://example.com/sqli"],
                cweId: "CWE-89"
            )
        ]
    }
    
    private func loadSampleExploits() {
        exploitEntries = [
            ExploitEntry(
                id: "12345",
                cveId: "CVE-2024-1234",
                title: "Example Software RCE Exploit",
                author: "Security Researcher",
                platform: ["Windows", "Linux"],
                type: .remote,
                code: nil,
                verifiedWorking: true,
                lastTested: Date(),
                difficulty: .medium,
                tags: ["rce", "remote", "example"],
                references: ["https://exploit-db.com/exploits/12345"]
            )
        ]
    }
    
    private func loadSampleMetasploitModules() {
        metasploitModules = [
            MetasploitModule(
                name: "windows/smb/ms17_010_eternalblue",
                fullName: "exploit/windows/smb/ms17_010_eternalblue",
                cveId: "CVE-2017-0144",
                description: "MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption",
                rank: .great,
                targets: ["Windows 7", "Windows Server 2008", "Windows Server 2012"],
                payloads: ["windows/x64/meterpreter/reverse_tcp", "windows/x64/shell/reverse_tcp"],
                difficulty: .medium,
                category: .exploit,
                lastUpdate: Date(),
                isReliable: true
            ),
            MetasploitModule(
                name: "multi/handler",
                fullName: "exploit/multi/handler",
                cveId: nil,
                description: "Generic Payload Handler",
                rank: .manual,
                targets: ["Universal"],
                payloads: ["generic/shell_reverse_tcp", "windows/meterpreter/reverse_tcp"],
                difficulty: .easy,
                category: .exploit,
                lastUpdate: Date(),
                isReliable: true
            )
        ]
    }
    
    // MARK: - CVSS Score Helper Functions
    
    private func confidentialityScore(_ impact: CVSSMetrics.Impact) -> Double {
        switch impact {
        case .none: return 0.0
        case .low: return 0.22
        case .high: return 0.56
        }
    }
    
    private func integrityScore(_ impact: CVSSMetrics.Impact) -> Double {
        switch impact {
        case .none: return 0.0
        case .low: return 0.22
        case .high: return 0.56
        }
    }
    
    private func availabilityScore(_ impact: CVSSMetrics.Impact) -> Double {
        switch impact {
        case .none: return 0.0
        case .low: return 0.22
        case .high: return 0.56
        }
    }
    
    private func attackVectorScore(_ vector: CVSSMetrics.AttackVector) -> Double {
        switch vector {
        case .network: return 0.85
        case .adjacent: return 0.62
        case .local: return 0.55
        case .physical: return 0.2
        }
    }
    
    private func attackComplexityScore(_ complexity: CVSSMetrics.AttackComplexity) -> Double {
        switch complexity {
        case .low: return 0.77
        case .high: return 0.44
        }
    }
    
    private func privilegesRequiredScore(_ privileges: CVSSMetrics.PrivilegesRequired, scope: CVSSMetrics.Scope) -> Double {
        switch privileges {
        case .none: return 0.85
        case .low: return scope == .unchanged ? 0.62 : 0.68
        case .high: return scope == .unchanged ? 0.27 : 0.5
        }
    }
    
    private func userInteractionScore(_ interaction: CVSSMetrics.UserInteraction) -> Double {
        switch interaction {
        case .none: return 0.85
        case .required: return 0.62
        }
    }
    
    private func exploitCodeMaturityScore(_ maturity: CVSSMetrics.ExploitCodeMaturity) -> Double {
        switch maturity {
        case .notDefined: return 1.0
        case .unproven: return 0.91
        case .proofOfConcept: return 0.94
        case .functional: return 0.97
        case .high: return 1.0
        }
    }
    
    private func remediationLevelScore(_ level: CVSSMetrics.RemediationLevel) -> Double {
        switch level {
        case .notDefined: return 1.0
        case .officialFix: return 0.95
        case .temporaryFix: return 0.96
        case .workaround: return 0.97
        case .unavailable: return 1.0
        }
    }
    
    private func reportConfidenceScore(_ confidence: CVSSMetrics.ReportConfidence) -> Double {
        switch confidence {
        case .notDefined: return 1.0
        case .unknown: return 0.92
        case .reasonable: return 0.96
        case .confirmed: return 1.0
        }
    }
    
    private func generateCVSSVector(_ metrics: CVSSMetrics) -> String {
        var vector = "CVSS:3.1"
        vector += "/AV:\(attackVectorAbbrev(metrics.attackVector))"
        vector += "/AC:\(attackComplexityAbbrev(metrics.attackComplexity))"
        vector += "/PR:\(privilegesRequiredAbbrev(metrics.privilegesRequired))"
        vector += "/UI:\(userInteractionAbbrev(metrics.userInteraction))"
        vector += "/S:\(scopeAbbrev(metrics.scope))"
        vector += "/C:\(impactAbbrev(metrics.confidentialityImpact))"
        vector += "/I:\(impactAbbrev(metrics.integrityImpact))"
        vector += "/A:\(impactAbbrev(metrics.availabilityImpact))"
        
        if let ecm = metrics.exploitCodeMaturity {
            vector += "/E:\(exploitCodeMaturityAbbrev(ecm))"
        }
        if let rl = metrics.remediationLevel {
            vector += "/RL:\(remediationLevelAbbrev(rl))"
        }
        if let rc = metrics.reportConfidence {
            vector += "/RC:\(reportConfidenceAbbrev(rc))"
        }
        
        return vector
    }
    
    private func attackVectorAbbrev(_ vector: CVSSMetrics.AttackVector) -> String {
        switch vector {
        case .network: return "N"
        case .adjacent: return "A"
        case .local: return "L"
        case .physical: return "P"
        }
    }
    
    private func attackComplexityAbbrev(_ complexity: CVSSMetrics.AttackComplexity) -> String {
        switch complexity {
        case .low: return "L"
        case .high: return "H"
        }
    }
    
    private func privilegesRequiredAbbrev(_ privileges: CVSSMetrics.PrivilegesRequired) -> String {
        switch privileges {
        case .none: return "N"
        case .low: return "L"
        case .high: return "H"
        }
    }
    
    private func userInteractionAbbrev(_ interaction: CVSSMetrics.UserInteraction) -> String {
        switch interaction {
        case .none: return "N"
        case .required: return "R"
        }
    }
    
    private func scopeAbbrev(_ scope: CVSSMetrics.Scope) -> String {
        switch scope {
        case .unchanged: return "U"
        case .changed: return "C"
        }
    }
    
    private func impactAbbrev(_ impact: CVSSMetrics.Impact) -> String {
        switch impact {
        case .none: return "N"
        case .low: return "L"
        case .high: return "H"
        }
    }
    
    private func exploitCodeMaturityAbbrev(_ maturity: CVSSMetrics.ExploitCodeMaturity) -> String {
        switch maturity {
        case .notDefined: return "X"
        case .unproven: return "U"
        case .proofOfConcept: return "P"
        case .functional: return "F"
        case .high: return "H"
        }
    }
    
    private func remediationLevelAbbrev(_ level: CVSSMetrics.RemediationLevel) -> String {
        switch level {
        case .notDefined: return "X"
        case .officialFix: return "O"
        case .temporaryFix: return "T"
        case .workaround: return "W"
        case .unavailable: return "U"
        }
    }
    
    private func reportConfidenceAbbrev(_ confidence: CVSSMetrics.ReportConfidence) -> String {
        switch confidence {
        case .notDefined: return "X"
        case .unknown: return "U"
        case .reasonable: return "R"
        case .confirmed: return "C"
        }
    }
}

// MARK: - Supporting Models

struct ExploitCode {
    let id: String
    let code: String
    let downloadDate: Date
    let size: Int
}

enum ExploitDatabaseError: Error {
    case invalidURL
    case networkError
    case parsingError
    case notFound
}

// MARK: - NVD API Response Models

struct NVDResponse: Codable {
    let vulnerabilities: [NVDVulnerability]
    let resultsPerPage: Int
    let startIndex: Int
    let totalResults: Int
}

struct NVDVulnerability: Codable {
    let cve: NVDCVEItem?
    let publishedDate: String
    let lastModifiedDate: String
    let metrics: NVDMetrics?
    let configurations: [NVDConfiguration]?
}

struct NVDCVEItem: Codable {
    let id: String
    let descriptions: [NVDDescription]
    let references: [NVDReference]?
    let weaknesses: [NVDWeakness]?
}

struct NVDDescription: Codable {
    let lang: String
    let value: String
}

struct NVDReference: Codable {
    let url: String
    let source: String?
}

struct NVDWeakness: Codable {
    let description: [NVDDescription]?
}

struct NVDMetrics: Codable {
    let cvssMetricV31: [NVDCVSSMetric]?
}

struct NVDCVSSMetric: Codable {
    let cvssData: NVDCVSSData
    let impactScore: Double?
    let exploitabilityScore: Double?
}

struct NVDCVSSData: Codable {
    let version: String
    let vectorString: String
    let baseScore: Double
    let baseSeverity: String
}

struct NVDConfiguration: Codable {
    let nodes: [NVDNode]
}

struct NVDNode: Codable {
    let `operator`: String?
    let cpeMatch: [NVDCPEMatch]
}

struct NVDCPEMatch: Codable {
    let vulnerable: Bool
    let criteria: String?
    let versionStartIncluding: String?
    let versionEndExcluding: String?
}