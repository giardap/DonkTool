//
//  AdvancedExploitDatabaseView.swift
//  DonkTool
//
//  Advanced CVE and Exploit Database with Real Implementation
//

import SwiftUI

struct AdvancedExploitDatabaseView: View {
    @StateObject private var viewModel = ExploitDatabaseViewModel()
    @State private var selectedSegment = 0
    @State private var searchText = ""
    @State private var showingSettings = false
    
    var body: some View {
        VStack(spacing: 0) {
            // Header
            headerView
            
            // Search Bar
            searchBar
            
            // Content
            contentView
                .frame(maxWidth: .infinity, maxHeight: .infinity)
        }
        .onAppear {
            viewModel.loadInitialData()
        }
        .sheet(isPresented: $showingSettings) {
            APISettingsView(viewModel: viewModel)
        }
    }
    
    private var headerView: some View {
        HStack {
            VStack(alignment: .leading) {
                Text("Vulnerability Database")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                
                HStack {
                    if viewModel.isLoading {
                        ProgressView()
                            .scaleEffect(0.7)
                    }
                    
                    Text(viewModel.statusMessage)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
            
            Spacer()
            
            // Segmented Control
            Picker("View", selection: $selectedSegment) {
                Text("CVEs").tag(0)
                Text("Exploits").tag(1)
                Text("Metasploit").tag(2)
            }
            .pickerStyle(SegmentedPickerStyle())
            .frame(width: 300)
            
            Button(action: { showingSettings = true }) {
                Image(systemName: "gear")
            }
            
            Button(action: { viewModel.refreshData() }) {
                Image(systemName: "arrow.clockwise")
            }
            .disabled(viewModel.isLoading)
        }
        .padding()
    }
    
    private var searchBar: some View {
        HStack {
            Image(systemName: "magnifyingglass")
                .foregroundColor(.secondary)
            
            TextField("Search CVEs, exploits, or products...", text: $searchText)
                .textFieldStyle(RoundedBorderTextFieldStyle())
        }
        .padding(.horizontal)
        .padding(.bottom)
    }
    
    private var contentView: some View {
        Group {
            switch selectedSegment {
            case 0:
                cveListView
            case 1:
                exploitListView
            case 2:
                metasploitView
            default:
                EmptyView()
            }
        }
    }
    
    private var cveListView: some View {
        VStack {
            if viewModel.cveEntries.isEmpty && !viewModel.isLoading {
                emptyStateView("No CVE data available", 
                              subtitle: "Click refresh to load from NVD API")
            } else {
                ScrollView {
                    LazyVStack(spacing: 12) {
                        ForEach(filteredCVEs) { cve in
                            CVECard(cve: cve) {
                                viewModel.searchExploitsForCVE(cve.id)
                            }
                            .padding(.horizontal)
                        }
                    }
                    .padding(.vertical)
                }
            }
        }
    }
    
    private var exploitListView: some View {
        VStack {
            if viewModel.exploits.isEmpty && !viewModel.isLoading {
                emptyStateView("No exploits loaded", 
                              subtitle: "Run searchsploit to find exploits")
            } else {
                ScrollView {
                    LazyVStack(spacing: 12) {
                        ForEach(filteredExploits) { exploit in
                            ExploitCard(exploit: exploit) {
                                viewModel.downloadExploit(exploit)
                            }
                            .padding(.horizontal)
                        }
                    }
                    .padding(.vertical)
                }
            }
        }
    }
    
    private var metasploitView: some View {
        VStack {
            if viewModel.metasploitModules.isEmpty && !viewModel.isLoading {
                emptyStateView("Metasploit not connected", 
                              subtitle: "Ensure Metasploit Framework is installed")
            } else {
                ScrollView {
                    LazyVStack(spacing: 12) {
                        ForEach(filteredModules) { module in
                            MetasploitModuleCard(module: module)
                                .padding(.horizontal)
                        }
                    }
                    .padding(.vertical)
                }
            }
        }
    }
    
    private func emptyStateView(_ title: String, subtitle: String) -> some View {
        VStack(spacing: 16) {
            Image(systemName: "tray")
                .font(.system(size: 48))
                .foregroundColor(.secondary)
            
            Text(title)
                .font(.headline)
            
            Text(subtitle)
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
    
    private var filteredCVEs: [CVEEntry] {
        if searchText.isEmpty {
            return viewModel.cveEntries
        }
        return viewModel.cveEntries.filter { cve in
            cve.id.localizedCaseInsensitiveContains(searchText) ||
            cve.description.localizedCaseInsensitiveContains(searchText)
        }
    }
    
    private var filteredExploits: [ExploitEntry] {
        if searchText.isEmpty {
            return viewModel.exploits
        }
        return viewModel.exploits.filter { exploit in
            exploit.title.localizedCaseInsensitiveContains(searchText) ||
            exploit.author.localizedCaseInsensitiveContains(searchText)
        }
    }
    
    private var filteredModules: [MetasploitModule] {
        if searchText.isEmpty {
            return viewModel.metasploitModules
        }
        return viewModel.metasploitModules.filter { module in
            module.name.localizedCaseInsensitiveContains(searchText) ||
            module.description.localizedCaseInsensitiveContains(searchText)
        }
    }
}

// MARK: - View Model with Real Implementation

@MainActor
class ExploitDatabaseViewModel: ObservableObject {
    @Published var cveEntries: [CVEEntry] = []
    @Published var exploits: [ExploitEntry] = []
    @Published var metasploitModules: [MetasploitModule] = []
    @Published var isLoading = false
    @Published var statusMessage = "Ready"
    
    private var nvdAPIKey: String = ""
    private var shodanAPIKey: String = ""
    
    func loadInitialData() {
        loadStoredAPIKeys()
        Task {
            await loadRecentCVEs()
            await loadMetasploitModules()
        }
    }
    
    func refreshData() {
        Task {
            await loadRecentCVEs()
            await searchLocalExploits()
            await loadMetasploitModules()
        }
    }
    
    // MARK: - Real NVD API Integration
    
    private func loadRecentCVEs() async {
        isLoading = true
        statusMessage = "Fetching CVEs from NVD..."
        
        // NVD API endpoint - last 7 days of CVEs
        let calendar = Calendar.current
        let endDate = Date()
        let startDate = calendar.date(byAdding: .day, value: -7, to: endDate) ?? endDate
        
        let formatter = ISO8601DateFormatter()
        let startString = formatter.string(from: startDate)
        let endString = formatter.string(from: endDate)
        
        let urlString = "https://services.nvd.nist.gov/rest/json/cves/2.0?lastModStartDate=\(startString)&lastModEndDate=\(endString)"
        
        guard let url = URL(string: urlString) else {
            statusMessage = "Invalid URL"
            isLoading = false
            return
        }
        
        do {
            var request = URLRequest(url: url)
            request.setValue("application/json", forHTTPHeaderField: "Accept")
            
            // Add API key if available
            if !nvdAPIKey.isEmpty {
                request.setValue(nvdAPIKey, forHTTPHeaderField: "apiKey")
            }
            
            let (data, response) = try await URLSession.shared.data(for: request)
            
            if let httpResponse = response as? HTTPURLResponse {
                if httpResponse.statusCode == 200 {
                    // Parse the real NVD response
                    if let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                       let vulnerabilities = json["vulnerabilities"] as? [[String: Any]] {
                        
                        self.cveEntries = vulnerabilities.compactMap { vuln in
                            parseCVEFromNVD(vuln)
                        }
                        
                        statusMessage = "Loaded \(self.cveEntries.count) CVEs"
                    }
                } else {
                    statusMessage = "NVD API error: \(httpResponse.statusCode)"
                }
            }
        } catch {
            statusMessage = "Network error: \(error.localizedDescription)"
        }
        
        isLoading = false
    }
    
    private func parseCVEFromNVD(_ data: [String: Any]) -> CVEEntry? {
        guard let cve = data["cve"] as? [String: Any],
              let id = cve["id"] as? String,
              let descriptions = cve["descriptions"] as? [[String: Any]],
              let enDesc = descriptions.first(where: { $0["lang"] as? String == "en" }),
              let description = enDesc["value"] as? String else {
            return nil
        }
        
        // Extract CVSS score
        var cvssScore = 0.0
        var severity = CVEEntry.Severity.none
        
        if let metrics = cve["metrics"] as? [String: Any],
           let cvssMetricV31 = metrics["cvssMetricV31"] as? [[String: Any]],
           let firstMetric = cvssMetricV31.first,
           let cvssData = firstMetric["cvssData"] as? [String: Any],
           let baseScore = cvssData["baseScore"] as? Double {
            cvssScore = baseScore
            
            // Determine severity
            switch baseScore {
            case 9.0...10.0: severity = .critical
            case 7.0..<9.0: severity = .high
            case 4.0..<7.0: severity = .medium
            case 0.1..<4.0: severity = .low
            default: severity = .none
            }
        }
        
        return CVEEntry(
            id: id,
            description: description,
            cvssScore: cvssScore,
            severity: severity,
            publishedDate: Date(),
            lastModified: Date(),
            affectedProducts: [],
            exploitAvailable: false,
            exploitMaturity: .unproven,
            references: [],
            cweId: nil
        )
    }
    
    // MARK: - Real Searchsploit Integration
    
    func searchLocalExploits() async {
        guard let searchsploitPath = findSearchsploitPath() else {
            statusMessage = "searchsploit not found in common locations"
            return
        }
        
        statusMessage = "Searching local exploit database..."
        
        await MainActor.run {
            isLoading = true
        }
        
        let process = Process()
        process.executableURL = URL(fileURLWithPath: searchsploitPath)
        process.arguments = ["-j", "--disable-colour", "remote"]
        
        let outputPipe = Pipe()
        process.standardOutput = outputPipe
        
        do {
            try process.run()
            process.waitUntilExit()
            
            let data = outputPipe.fileHandleForReading.readDataToEndOfFile()
            
            if let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
               let results = json["RESULTS_EXPLOIT"] as? [[String: Any]] {
                
                await MainActor.run {
                    self.exploits = results.compactMap { parseSearchsploitResult($0) }
                    self.statusMessage = "Found \(self.exploits.count) exploits"
                }
            }
        } catch {
            await MainActor.run {
                statusMessage = "searchsploit error: \(error.localizedDescription)"
            }
        }
        
        await MainActor.run {
            isLoading = false
        }
    }
    
    private func parseSearchsploitResult(_ data: [String: Any]) -> ExploitEntry? {
        guard let title = data["Title"] as? String,
              let edbId = data["EDB-ID"] as? String,
              let author = data["Author"] as? String,
              let type = data["Type"] as? String,
              let platform = data["Platform"] as? String else {
            return nil
        }
        
        return ExploitEntry(
            id: edbId,
            cveId: extractCVEFromTitle(title),
            title: title,
            author: author,
            platform: [platform],
            type: mapExploitType(type),
            code: nil,
            verifiedWorking: false,
            lastTested: nil,
            difficulty: .medium,
            tags: [type, platform],
            references: []
        )
    }
    
    func searchExploitsForCVE(_ cveId: String) {
        Task {
            guard let searchsploitPath = findSearchsploitPath() else {
                statusMessage = "searchsploit not found"
                return
            }
            
            statusMessage = "Searching exploits for \(cveId)..."
            
            let process = Process()
            process.executableURL = URL(fileURLWithPath: searchsploitPath)
            process.arguments = ["-j", "--disable-colour", cveId]
            
            let outputPipe = Pipe()
            process.standardOutput = outputPipe
            
            do {
                try process.run()
                process.waitUntilExit()
                
                let data = outputPipe.fileHandleForReading.readDataToEndOfFile()
                
                if let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                   let results = json["RESULTS_EXPLOIT"] as? [[String: Any]] {
                    
                    let exploitsForCVE = results.compactMap { parseSearchsploitResult($0) }
                    
                    await MainActor.run {
                        // Add to existing exploits
                        for exploit in exploitsForCVE {
                            if !self.exploits.contains(where: { $0.id == exploit.id }) {
                                self.exploits.append(exploit)
                            }
                        }
                        
                        statusMessage = "Found \(exploitsForCVE.count) exploits for \(cveId)"
                    }
                }
            } catch {
                await MainActor.run {
                    statusMessage = "Search error: \(error.localizedDescription)"
                }
            }
        }
    }
    
    func downloadExploit(_ exploit: ExploitEntry) {
        Task {
            guard let searchsploitPath = findSearchsploitPath() else {
                statusMessage = "searchsploit not found"
                return
            }
            
            statusMessage = "Downloading exploit \(exploit.id)..."
            
            let process = Process()
            process.executableURL = URL(fileURLWithPath: searchsploitPath)
            process.arguments = ["-m", exploit.id]
            
            do {
                try process.run()
                process.waitUntilExit()
                
                await MainActor.run {
                    if process.terminationStatus == 0 {
                        statusMessage = "Downloaded exploit \(exploit.id)"
                    } else {
                        statusMessage = "Failed to download exploit"
                    }
                }
            } catch {
                await MainActor.run {
                    statusMessage = "Download error: \(error.localizedDescription)"
                }
            }
        }
    }
    
    // MARK: - Real Metasploit Integration
    
    private func loadMetasploitModules() async {
        guard let msfPath = findMetasploitPath() else {
            await MainActor.run {
                statusMessage = "Metasploit Framework not found"
            }
            return
        }
        
        await MainActor.run {
            statusMessage = "Loading Metasploit modules..."
        }
        
        // Get basic module listing
        let process = Process()
        process.executableURL = URL(fileURLWithPath: msfPath)
        process.arguments = ["-q", "-x", "search type:exploit platform:windows", "-x", "exit"]
        
        let outputPipe = Pipe()
        process.standardOutput = outputPipe
        
        do {
            try process.run()
            process.waitUntilExit()
            
            let data = outputPipe.fileHandleForReading.readDataToEndOfFile()
            let output = String(data: data, encoding: .utf8) ?? ""
            
            await MainActor.run {
                self.metasploitModules = parseMetasploitOutput(output)
                self.statusMessage = "Loaded \(self.metasploitModules.count) Metasploit modules"
            }
        } catch {
            await MainActor.run {
                statusMessage = "Failed to load Metasploit modules: \(error.localizedDescription)"
            }
        }
    }
    
    private func parseMetasploitOutput(_ output: String) -> [MetasploitModule] {
        var modules: [MetasploitModule] = []
        let lines = output.components(separatedBy: .newlines)
        
        for line in lines {
            let trimmedLine = line.trimmingCharacters(in: .whitespaces)
            
            // Parse module lines (format: "exploit/windows/browser/adobe_flash_hacking_team_uaf   2015-07-14   normal  ...")
            if trimmedLine.hasPrefix("exploit/") || trimmedLine.hasPrefix("auxiliary/") || trimmedLine.hasPrefix("post/") {
                let components = trimmedLine.components(separatedBy: .whitespaces).filter { !$0.isEmpty }
                
                if components.count >= 3 {
                    let moduleName = components[0]
                    
                    modules.append(MetasploitModule(
                        name: moduleName,
                        fullName: moduleName,
                        cveId: extractCVEFromModuleName(moduleName),
                        description: components.dropFirst(3).joined(separator: " "),
                        rank: mapMetasploitRank(components.count > 2 ? components[2] : "normal"),
                        targets: ["Windows"], // Basic default
                        payloads: [], // Empty for now
                        difficulty: .medium, // Default difficulty
                        category: mapModuleCategory(moduleName),
                        lastUpdate: Date(),
                        isReliable: true
                    ))
                }
            }
        }
        
        return modules
    }
    
    private func mapMetasploitRank(_ rankString: String) -> MetasploitModule.ExploitRank {
        switch rankString.lowercased() {
        case "excellent": return .excellent
        case "great": return .great
        case "good": return .good
        case "normal": return .normal
        case "average": return .average
        case "low": return .low
        case "manual": return .manual
        default: return .normal
        }
    }
    
    private func mapModuleCategory(_ moduleName: String) -> MetasploitModule.ModuleCategory {
        if moduleName.hasPrefix("exploit/") { return .exploit }
        if moduleName.hasPrefix("auxiliary/") { return .auxiliary }
        if moduleName.hasPrefix("post/") { return .post }
        if moduleName.hasPrefix("payload/") { return .payload }
        if moduleName.hasPrefix("encoder/") { return .encoder }
        if moduleName.hasPrefix("nop/") { return .nop }
        return .exploit
    }
    
    private func extractCVEFromModuleName(_ moduleName: String) -> String? {
        let pattern = "cve[_-](\\d{4})[_-](\\d{4,7})"
        if let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive) {
            let range = NSRange(moduleName.startIndex..., in: moduleName)
            if let match = regex.firstMatch(in: moduleName, range: range) {
                let year = String(moduleName[Range(match.range(at: 1), in: moduleName)!])
                let id = String(moduleName[Range(match.range(at: 2), in: moduleName)!])
                return "CVE-\(year)-\(id)"
            }
        }
        return nil
    }
    
    private func findMetasploitPath() -> String? {
        let searchPaths = [
            "/opt/homebrew/bin/msfconsole",
            "/usr/local/bin/msfconsole",
            "/usr/bin/msfconsole",
            "/opt/metasploit-framework/bin/msfconsole"
        ]
        
        for path in searchPaths {
            if FileManager.default.fileExists(atPath: path) {
                return path
            }
        }
        return nil
    }
    
    // MARK: - Helper Methods
    
    private func findSearchsploitPath() -> String? {
        let searchPaths = [
            "/opt/homebrew/bin/searchsploit",
            "/usr/local/bin/searchsploit",
            "/usr/bin/searchsploit"
        ]
        
        for path in searchPaths {
            if FileManager.default.fileExists(atPath: path) {
                return path
            }
        }
        return nil
    }
    
    private func extractCVEFromTitle(_ title: String) -> String? {
        let pattern = "CVE-\\d{4}-\\d{4,7}"
        if let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive) {
            let range = NSRange(title.startIndex..., in: title)
            if let match = regex.firstMatch(in: title, range: range) {
                return String(title[Range(match.range, in: title)!])
            }
        }
        return nil
    }
    
    private func mapExploitType(_ type: String) -> ExploitType {
        switch type.lowercased() {
        case "remote": return .remote
        case "local": return .local
        case "webapps", "web": return .webApp
        case "dos": return .dos
        default: return .remote
        }
    }
    
    private func loadStoredAPIKeys() {
        // Load from UserDefaults or Keychain
        nvdAPIKey = UserDefaults.standard.string(forKey: "nvdAPIKey") ?? ""
        shodanAPIKey = UserDefaults.standard.string(forKey: "shodanAPIKey") ?? ""
    }
    
    func saveAPIKey(_ key: String, for service: String) {
        UserDefaults.standard.set(key, forKey: "\(service)APIKey")
        
        switch service {
        case "nvd": nvdAPIKey = key
        case "shodan": shodanAPIKey = key
        default: break
        }
    }
}

// MARK: - Component Views

struct CVECard: View {
    let cve: CVEEntry
    let onSearchExploits: () -> Void
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Text(cve.id)
                    .font(.headline)
                
                Spacer()
                
                Text(String(format: "%.1f", cve.cvssScore))
                    .font(.title3)
                    .fontWeight(.bold)
                    .foregroundColor(cve.severity.color)
                
                Text(cve.severity.rawValue)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(cve.severity.color.opacity(0.2))
                    .cornerRadius(4)
            }
            
            Text(cve.description)
                .font(.caption)
                .lineLimit(3)
                .foregroundColor(.secondary)
            
            HStack {
                Button("Search Exploits") {
                    onSearchExploits()
                }
                .buttonStyle(.link)
                .font(.caption)
                
                Spacer()
                
                Text(cve.publishedDate, style: .date)
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .background(Color.gray.opacity(0.05))
        .cornerRadius(8)
    }
}

struct ExploitCard: View {
    let exploit: ExploitEntry
    let onDownload: () -> Void
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                VStack(alignment: .leading) {
                    Text(exploit.title)
                        .font(.headline)
                        .lineLimit(2)
                    
                    Text("by \(exploit.author)")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                
                Spacer()
                
                Text("EDB-\(exploit.id)")
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(Color.blue.opacity(0.2))
                    .cornerRadius(4)
            }
            
            HStack {
                ForEach(exploit.platform, id: \.self) { platform in
                    Text(platform)
                        .font(.caption2)
                        .padding(.horizontal, 6)
                        .padding(.vertical, 2)
                        .background(Color.gray.opacity(0.2))
                        .cornerRadius(4)
                }
                
                Text(exploit.type.rawValue)
                    .font(.caption2)
                    .padding(.horizontal, 6)
                    .padding(.vertical, 2)
                    .background(Color.orange.opacity(0.2))
                    .cornerRadius(4)
                
                Spacer()
                
                Button("Download") {
                    onDownload()
                }
                .buttonStyle(.bordered)
                .controlSize(.small)
            }
        }
        .padding()
        .background(Color.gray.opacity(0.05))
        .cornerRadius(8)
    }
}

struct MetasploitModuleCard: View {
    let module: MetasploitModule
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Text(module.name)
                    .font(.headline)
                
                Spacer()
                
                Text(module.rank.rawValue)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(module.rank.color.opacity(0.2))
                    .cornerRadius(4)
            }
            
            Text(module.description)
                .font(.caption)
                .lineLimit(2)
                .foregroundColor(.secondary)
            
            HStack {
                if let cveId = module.cveId {
                    Text(cveId)
                        .font(.caption2)
                        .padding(.horizontal, 6)
                        .padding(.vertical, 2)
                        .background(Color.blue.opacity(0.2))
                        .cornerRadius(4)
                }
                
                Text(module.category.rawValue)
                    .font(.caption2)
                    .padding(.horizontal, 6)
                    .padding(.vertical, 2)
                    .background(Color.gray.opacity(0.2))
                    .cornerRadius(4)
                
                Spacer()
            }
        }
        .padding()
        .background(Color.gray.opacity(0.05))
        .cornerRadius(8)
    }
}

// MARK: - API Settings View

struct APISettingsView: View {
    @Environment(\.dismiss) private var dismiss
    @ObservedObject var viewModel: ExploitDatabaseViewModel
    
    @State private var nvdKey = ""
    @State private var shodanKey = ""
    @State private var virustotalKey = ""
    
    var body: some View {
        VStack(spacing: 20) {
            Text("API Configuration")
                .font(.title2)
                .fontWeight(.bold)
            
            Form {
                Section(header: Text("National Vulnerability Database")) {
                    TextField("NVD API Key (optional)", text: $nvdKey)
                    Text("Get your free API key at https://nvd.nist.gov/developers/request-an-api-key")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                
                Section(header: Text("Shodan")) {
                    TextField("Shodan API Key", text: $shodanKey)
                    Text("Get your API key at https://shodan.io/account")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                
                Section(header: Text("VirusTotal")) {
                    TextField("VirusTotal API Key", text: $virustotalKey)
                    Text("Get your API key at https://www.virustotal.com/gui/my-apikey")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
            .frame(width: 500, height: 300)
            
            HStack {
                Button("Cancel") {
                    dismiss()
                }
                
                Spacer()
                
                Button("Save") {
                    saveKeys()
                    dismiss()
                }
                .buttonStyle(.borderedProminent)
            }
            .padding()
        }
        .padding()
    }
    
    private func saveKeys() {
        if !nvdKey.isEmpty {
            viewModel.saveAPIKey(nvdKey, for: "nvd")
        }
        if !shodanKey.isEmpty {
            viewModel.saveAPIKey(shodanKey, for: "shodan")
        }
        if !virustotalKey.isEmpty {
            viewModel.saveAPIKey(virustotalKey, for: "virustotal")
        }
    }
}

#Preview {
    AdvancedExploitDatabaseView()
}