//
//  AdvancedExploitDatabaseView.swift
//  DonkTool
//
//  Advanced CVE and Exploit Database with Real Implementation
//

import SwiftUI
import Foundation

struct AdvancedExploitDatabaseView: View {
    @StateObject private var viewModel = ExploitDatabaseViewModel()
    @State private var selectedSegment = 0
    @State private var searchText = ""
    @State private var showingSettings = false
    
    var body: some View {
        VStack(spacing: 0) {
            // Header
            headerView
            
            // Search Bar
            searchBar
            
            // Content
            contentView
                .frame(maxWidth: .infinity, maxHeight: .infinity)
        }
        .onAppear {
            viewModel.loadInitialData()
        }
        .sheet(isPresented: $showingSettings) {
            APISettingsView(viewModel: viewModel)
        }
    }
    
    private var headerView: some View {
        HStack {
            VStack(alignment: .leading) {
                Text("Vulnerability Database")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                
                HStack {
                    if viewModel.isLoading {
                        HStack(spacing: 6) {
                            Image(systemName: "arrow.clockwise")
                                .font(.caption)
                                .foregroundColor(.blue)
                                .rotationEffect(.degrees(viewModel.isLoading ? 360 : 0))
                                .animation(.linear(duration: 1.0).repeatForever(autoreverses: false), value: viewModel.isLoading)
                        }
                    }
                    
                    Text(viewModel.statusMessage)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
            
            Spacer()
            
            // Segmented Control
            Picker("View", selection: $selectedSegment) {
                Text("CVEs").tag(0)
                Text("Exploits").tag(1)
                Text("Metasploit").tag(2)
            }
            .pickerStyle(SegmentedPickerStyle())
            .frame(width: 300)
            
            Button(action: { showingSettings = true }) {
                Image(systemName: "gear")
            }
            
            Button(action: { viewModel.refreshData() }) {
                Image(systemName: "arrow.clockwise")
            }
            .disabled(viewModel.isLoading)
        }
        .padding()
    }
    
    private var searchBar: some View {
        HStack {
            Image(systemName: "magnifyingglass")
                .foregroundColor(.secondary)
            
            TextField("Search CVEs, exploits, or products...", text: $searchText)
                .textFieldStyle(RoundedBorderTextFieldStyle())
        }
        .padding(.horizontal)
        .padding(.bottom)
    }
    
    private var contentView: some View {
        Group {
            switch selectedSegment {
            case 0:
                cveListView
            case 1:
                exploitListView
            case 2:
                metasploitView
            default:
                EmptyView()
            }
        }
    }
    
    private var cveListView: some View {
        VStack {
            if viewModel.cveEntries.isEmpty && !viewModel.isLoading {
                emptyStateView("No CVE data available", 
                              subtitle: "Click refresh to load from NVD API")
            } else {
                ScrollView {
                    LazyVStack(spacing: 12) {
                        ForEach(filteredCVEs) { cve in
                            CVECard(cve: cve) {
                                viewModel.searchExploitsForCVE(cve.id)
                            }
                            .padding(.horizontal)
                        }
                    }
                    .padding(.vertical)
                }
            }
        }
    }
    
    private var exploitListView: some View {
        VStack {
            if viewModel.exploits.isEmpty && !viewModel.isLoading {
                emptyStateView("No exploits loaded", 
                              subtitle: "Run searchsploit to find exploits")
            } else {
                ScrollView {
                    LazyVStack(spacing: 12) {
                        ForEach(filteredExploits) { exploit in
                            ExploitCard(exploit: exploit) {
                                viewModel.downloadExploit(exploit)
                            }
                            .padding(.horizontal)
                        }
                    }
                    .padding(.vertical)
                }
            }
        }
    }
    
    private var metasploitView: some View {
        VStack {
            if viewModel.metasploitModules.isEmpty && !viewModel.isLoading {
                emptyStateView("Metasploit not connected", 
                              subtitle: "Ensure Metasploit Framework is installed")
            } else {
                ScrollView {
                    LazyVStack(spacing: 12) {
                        ForEach(filteredModules) { module in
                            MetasploitModuleCard(module: module)
                                .padding(.horizontal)
                        }
                    }
                    .padding(.vertical)
                }
            }
        }
    }
    
    private func emptyStateView(_ title: String, subtitle: String) -> some View {
        VStack(spacing: 16) {
            Image(systemName: "tray")
                .font(.system(size: 48))
                .foregroundColor(.secondary)
            
            Text(title)
                .font(.headline)
            
            Text(subtitle)
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
    
    private var filteredCVEs: [CVEEntry] {
        if searchText.isEmpty {
            return viewModel.cveEntries
        }
        return viewModel.cveEntries.filter { cve in
            cve.id.localizedCaseInsensitiveContains(searchText) ||
            cve.description.localizedCaseInsensitiveContains(searchText)
        }
    }
    
    private var filteredExploits: [ExploitEntry] {
        if searchText.isEmpty {
            return viewModel.exploits
        }
        return viewModel.exploits.filter { exploit in
            exploit.title.localizedCaseInsensitiveContains(searchText) ||
            exploit.author.localizedCaseInsensitiveContains(searchText)
        }
    }
    
    private var filteredModules: [MetasploitModule] {
        if searchText.isEmpty {
            return viewModel.metasploitModules
        }
        return viewModel.metasploitModules.filter { module in
            module.name.localizedCaseInsensitiveContains(searchText) ||
            module.description.localizedCaseInsensitiveContains(searchText)
        }
    }
}

// MARK: - View Model with Real Implementation

@MainActor
class ExploitDatabaseViewModel: ObservableObject {
    @Published var cveEntries: [CVEEntry] = []
    @Published var exploits: [ExploitEntry] = []
    @Published var metasploitModules: [MetasploitModule] = []
    @Published var isLoading = false
    @Published var statusMessage = "Ready"
    
    private var nvdAPIKey: String = ""
    private var shodanAPIKey: String = ""
    
    func loadInitialData() {
        loadStoredAPIKeys()
        isLoading = true
        statusMessage = "Initializing..."
        
        Task {
            // Load CVEs first (most important)
            await loadRecentCVEs()
            
            // Then try Metasploit (optional, might fail)
            await loadMetasploitModulesSafely()
            
            await MainActor.run {
                isLoading = false
                if cveEntries.isEmpty && metasploitModules.isEmpty {
                    statusMessage = "Ready - Click refresh to load data"
                } else {
                    statusMessage = "Loaded \(cveEntries.count) CVEs, \(metasploitModules.count) modules"
                }
            }
        }
    }
    
    func refreshData() {
        isLoading = true
        statusMessage = "Refreshing data..."
        
        Task {
            // Load data sequentially to avoid crashes
            await loadRecentCVEs()
            await searchLocalExploitsSafely()
            await loadMetasploitModulesSafely()
            
            await MainActor.run {
                isLoading = false
                let total = cveEntries.count + exploits.count + metasploitModules.count
                statusMessage = "Refresh complete - \(total) items loaded"
            }
        }
    }
    
    // MARK: - Real NVD API Integration
    
    private func loadRecentCVEs() async {
        await MainActor.run {
            isLoading = true
            statusMessage = "Fetching CVEs from NVD..."
        }
        
        // NVD API endpoint - last 7 days of CVEs
        let calendar = Calendar.current
        let endDate = Date()
        let startDate = calendar.date(byAdding: .day, value: -7, to: endDate) ?? endDate
        
        let formatter = ISO8601DateFormatter()
        let startString = formatter.string(from: startDate)
        let endString = formatter.string(from: endDate)
        
        let urlString = "https://services.nvd.nist.gov/rest/json/cves/2.0?lastModStartDate=\(startString)&lastModEndDate=\(endString)"
        
        guard let url = URL(string: urlString) else {
            statusMessage = "Invalid URL"
            isLoading = false
            return
        }
        
        do {
            var request = URLRequest(url: url)
            request.setValue("application/json", forHTTPHeaderField: "Accept")
            request.timeoutInterval = 30.0
            
            // Add API key if available
            if !nvdAPIKey.isEmpty {
                request.setValue(nvdAPIKey, forHTTPHeaderField: "apiKey")
            }
            
            let (data, response) = try await URLSession.shared.data(for: request)
            
            if let httpResponse = response as? HTTPURLResponse {
                print("NVD API Response Status: \(httpResponse.statusCode)")
                
                if httpResponse.statusCode == 200 {
                    // Parse the real NVD response
                    do {
                        if let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] {
                            print("Successfully parsed JSON response")
                            
                            if let vulnerabilities = json["vulnerabilities"] as? [[String: Any]] {
                                print("Found \(vulnerabilities.count) vulnerabilities in response")
                                
                                let entries = vulnerabilities.compactMap { vuln in
                                    parseCVEFromNVD(vuln)
                                }
                                
                                await MainActor.run {
                                    self.cveEntries = entries
                                    statusMessage = "Loaded \(entries.count) CVEs from NVD"
                                }
                            } else {
                                await MainActor.run {
                                    statusMessage = "No vulnerabilities found in NVD response"
                                }
                            }
                        } else {
                            await MainActor.run {
                                statusMessage = "Failed to parse NVD JSON response"
                            }
                        }
                    } catch {
                        await MainActor.run {
                            statusMessage = "JSON parsing error: \(error.localizedDescription)"
                        }
                    }
                } else if httpResponse.statusCode == 403 {
                    await MainActor.run {
                        statusMessage = "API rate limit exceeded - try again later"
                    }
                } else {
                    await MainActor.run {
                        statusMessage = "NVD API error: \(httpResponse.statusCode)"
                    }
                }
            }
        } catch {
            await MainActor.run {
                statusMessage = "Network error: \(error.localizedDescription)"
            }
        }
        
        await MainActor.run {
            isLoading = false
        }
    }
    
    private func parseCVEFromNVD(_ data: [String: Any]) -> CVEEntry? {
        guard let cve = data["cve"] as? [String: Any],
              let id = cve["id"] as? String,
              let descriptions = cve["descriptions"] as? [[String: Any]],
              let enDesc = descriptions.first(where: { $0["lang"] as? String == "en" }),
              let description = enDesc["value"] as? String else {
            print("Failed to parse basic CVE data")
            return nil
        }
        
        // Extract CVSS score
        var cvssScore = 0.0
        var severity = CVEEntry.Severity.none
        
        // Try different CVSS versions
        if let metrics = cve["metrics"] as? [String: Any] {
            // Try CVSSv3.1 first
            if let cvssMetricV31 = metrics["cvssMetricV31"] as? [[String: Any]],
               let firstMetric = cvssMetricV31.first,
               let cvssData = firstMetric["cvssData"] as? [String: Any],
               let baseScore = cvssData["baseScore"] as? Double {
                cvssScore = baseScore
            }
            // Fall back to CVSSv3.0
            else if let cvssMetricV30 = metrics["cvssMetricV30"] as? [[String: Any]],
                    let firstMetric = cvssMetricV30.first,
                    let cvssData = firstMetric["cvssData"] as? [String: Any],
                    let baseScore = cvssData["baseScore"] as? Double {
                cvssScore = baseScore
            }
            // Fall back to CVSSv2.0
            else if let cvssMetricV2 = metrics["cvssMetricV2"] as? [[String: Any]],
                    let firstMetric = cvssMetricV2.first,
                    let cvssData = firstMetric["cvssData"] as? [String: Any],
                    let baseScore = cvssData["baseScore"] as? Double {
                cvssScore = baseScore
            }
            
            // Determine severity based on score
            switch cvssScore {
            case 9.0...10.0: severity = .critical
            case 7.0..<9.0: severity = .high
            case 4.0..<7.0: severity = .medium
            case 0.1..<4.0: severity = .low
            default: severity = .none
            }
        }
        
        // Parse dates
        let dateFormatter = ISO8601DateFormatter()
        var publishedDate = Date()
        var lastModified = Date()
        
        if let publishedString = cve["published"] as? String {
            publishedDate = dateFormatter.date(from: publishedString) ?? Date()
        }
        
        if let lastModifiedString = cve["lastModified"] as? String {
            lastModified = dateFormatter.date(from: lastModifiedString) ?? Date()
        }
        
        // Extract CWE information
        var cweId: String?
        if let weaknesses = cve["weaknesses"] as? [[String: Any]],
           let firstWeakness = weaknesses.first,
           let descriptions = firstWeakness["description"] as? [[String: Any]],
           let firstDesc = descriptions.first,
           let value = firstDesc["value"] as? String {
            cweId = value
        }
        
        // Extract references
        var references: [String] = []
        if let refs = cve["references"] as? [[String: Any]] {
            references = refs.compactMap { ref in
                return ref["url"] as? String
            }
        }
        
        return CVEEntry(
            id: id,
            description: description,
            cvssScore: cvssScore,
            severity: severity,
            publishedDate: publishedDate,
            lastModified: lastModified,
            affectedProducts: [],
            exploitAvailable: false,
            exploitMaturity: .unproven,
            references: references,
            cweId: cweId
        )
    }
    
    // MARK: - Real Searchsploit Integration
    
    func searchLocalExploits() async {
        guard let searchsploitPath = findSearchsploitPath() else {
            statusMessage = "searchsploit not found in common locations"
            return
        }
        
        statusMessage = "Searching local exploit database..."
        
        await MainActor.run {
            isLoading = true
        }
        
        let process = Process()
        process.executableURL = URL(fileURLWithPath: searchsploitPath)
        process.arguments = ["-j", "--disable-colour", "remote"]
        
        let outputPipe = Pipe()
        let errorPipe = Pipe()
        process.standardOutput = outputPipe
        process.standardError = errorPipe
        
        do {
            try process.run()
            
            // Wait for process with timeout checking
            var timeoutCounter = 0
            let maxTimeout = 5 // 5 seconds
            
            while process.isRunning && timeoutCounter < maxTimeout {
                try await Task.sleep(nanoseconds: 1_000_000_000) // 1 second
                timeoutCounter += 1
            }
            
            if process.isRunning {
                process.terminate()
                await MainActor.run {
                    statusMessage = "Searchsploit search timed out"
                }
                return
            }
            
            let data = outputPipe.fileHandleForReading.readDataToEndOfFile()
            
            if process.terminationStatus == 0 {
                if let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                   let results = json["RESULTS_EXPLOIT"] as? [[String: Any]] {
                    
                    await MainActor.run {
                        self.exploits = results.compactMap { parseSearchsploitResult($0) }
                        self.statusMessage = "Found \(self.exploits.count) exploits"
                    }
                } else {
                    await MainActor.run {
                        statusMessage = "Failed to parse searchsploit results"
                    }
                }
            } else {
                let errorData = errorPipe.fileHandleForReading.readDataToEndOfFile()
                let errorOutput = String(data: errorData, encoding: .utf8) ?? "Unknown error"
                await MainActor.run {
                    statusMessage = "Searchsploit failed: \(errorOutput.prefix(100))"
                }
            }
        } catch {
            await MainActor.run {
                statusMessage = "searchsploit error: \(error.localizedDescription)"
            }
        }
        
        await MainActor.run {
            isLoading = false
        }
    }
    
    private func parseSearchsploitResult(_ data: [String: Any]) -> ExploitEntry? {
        guard let title = data["Title"] as? String,
              let edbId = data["EDB-ID"] as? String,
              let author = data["Author"] as? String,
              let type = data["Type"] as? String,
              let platform = data["Platform"] as? String else {
            return nil
        }
        
        return ExploitEntry(
            id: edbId,
            title: title,
            author: author,
            date: "2024",
            type: type,
            platform: platform,
            path: "/tmp/\(edbId).txt",
            category: .exploit
        )
    }
    
    func searchExploitsForCVE(_ cveId: String) {
        Task {
            guard let searchsploitPath = findSearchsploitPath() else {
                statusMessage = "searchsploit not found"
                return
            }
            
            statusMessage = "Searching exploits for \(cveId)..."
            
            let process = Process()
            process.executableURL = URL(fileURLWithPath: searchsploitPath)
            process.arguments = ["-j", "--disable-colour", cveId]
            
            let outputPipe = Pipe()
            process.standardOutput = outputPipe
            
            do {
                try process.run()
                process.waitUntilExit()
                
                let data = outputPipe.fileHandleForReading.readDataToEndOfFile()
                
                if let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                   let results = json["RESULTS_EXPLOIT"] as? [[String: Any]] {
                    
                    let exploitsForCVE = results.compactMap { parseSearchsploitResult($0) }
                    
                    await MainActor.run {
                        // Add to existing exploits
                        for exploit in exploitsForCVE {
                            if !self.exploits.contains(where: { $0.id == exploit.id }) {
                                self.exploits.append(exploit)
                            }
                        }
                        
                        statusMessage = "Found \(exploitsForCVE.count) exploits for \(cveId)"
                    }
                }
            } catch {
                await MainActor.run {
                    statusMessage = "Search error: \(error.localizedDescription)"
                }
            }
        }
    }
    
    func downloadExploit(_ exploit: ExploitEntry) {
        Task {
            guard let searchsploitPath = findSearchsploitPath() else {
                statusMessage = "searchsploit not found"
                return
            }
            
            statusMessage = "Downloading exploit \(exploit.id)..."
            
            let process = Process()
            process.executableURL = URL(fileURLWithPath: searchsploitPath)
            process.arguments = ["-m", exploit.id]
            
            do {
                try process.run()
                process.waitUntilExit()
                
                await MainActor.run {
                    if process.terminationStatus == 0 {
                        statusMessage = "Downloaded exploit \(exploit.id)"
                    } else {
                        statusMessage = "Failed to download exploit"
                    }
                }
            } catch {
                await MainActor.run {
                    statusMessage = "Download error: \(error.localizedDescription)"
                }
            }
        }
    }
    
    // MARK: - Real Metasploit Integration
    
    private func loadMetasploitModules() async {
        guard let msfPath = findMetasploitPath() else {
            await MainActor.run {
                statusMessage = "Metasploit Framework not found"
            }
            return
        }
        
        await MainActor.run {
            statusMessage = "Loading Metasploit modules..."
        }
        
        // Get basic module listing with timeout protection
        let process = Process()
        process.executableURL = URL(fileURLWithPath: msfPath)
        process.arguments = ["-q", "-x", "search type:exploit platform:windows", "-x", "exit"]
        
        let outputPipe = Pipe()
        let errorPipe = Pipe()
        process.standardOutput = outputPipe
        process.standardError = errorPipe
        
        // Set a reasonable timeout for the process
        process.terminationHandler = { _ in
            // Process completed
        }
        
        do {
            try process.run()
            
            // Wait for process with timeout checking
            var timeoutCounter = 0
            let maxTimeout = 8 // 8 seconds
            
            while process.isRunning && timeoutCounter < maxTimeout {
                try await Task.sleep(nanoseconds: 1_000_000_000) // 1 second
                timeoutCounter += 1
            }
            
            if process.isRunning {
                process.terminate()
                await MainActor.run {
                    statusMessage = "Metasploit loading timed out"
                }
                return
            }
            
            let data = outputPipe.fileHandleForReading.readDataToEndOfFile()
            let output = String(data: data, encoding: .utf8) ?? ""
            
            if process.terminationStatus == 0 {
                await MainActor.run {
                    self.metasploitModules = parseMetasploitOutput(output)
                    self.statusMessage = "Loaded \(self.metasploitModules.count) Metasploit modules"
                }
            } else {
                let errorData = errorPipe.fileHandleForReading.readDataToEndOfFile()
                let errorOutput = String(data: errorData, encoding: .utf8) ?? "Unknown error"
                await MainActor.run {
                    statusMessage = "Metasploit failed: \(errorOutput.prefix(100))"
                }
            }
        } catch {
            await MainActor.run {
                statusMessage = "Failed to load Metasploit modules: \(error.localizedDescription)"
            }
        }
    }
    
    // MARK: - Safe Loading Functions
    
    private func loadMetasploitModulesSafely() async {
        do {
            // Use a timeout task to prevent hanging
            try await withTimeout(seconds: 10) {
                await self.loadMetasploitModules()
            }
        } catch {
            await MainActor.run {
                print("Metasploit loading failed safely: \(error)")
                self.statusMessage = "Metasploit loading skipped (timeout or error)"
            }
        }
    }
    
    private func searchLocalExploitsSafely() async {
        do {
            // Use a timeout task to prevent hanging
            try await withTimeout(seconds: 5) {
                await self.searchLocalExploits()
            }
        } catch {
            await MainActor.run {
                print("Exploit search failed safely: \(error)")
                self.statusMessage = "Local exploit search skipped (timeout or error)"
            }
        }
    }
    
    private func withTimeout<T>(seconds: Double, operation: @escaping () async throws -> T) async throws -> T {
        return try await withThrowingTaskGroup(of: T.self) { group in
            group.addTask {
                return try await operation()
            }
            
            group.addTask {
                try await Task.sleep(nanoseconds: UInt64(seconds * 1_000_000_000))
                throw TimeoutError()
            }
            
            guard let result = try await group.next() else {
                throw TimeoutError()
            }
            
            group.cancelAll()
            return result
        }
    }
    
    private struct TimeoutError: Error {
        let message = "Operation timed out"
    }
    
    private func parseMetasploitOutput(_ output: String) -> [MetasploitModule] {
        var modules: [MetasploitModule] = []
        let lines = output.components(separatedBy: .newlines)
        
        for line in lines {
            let trimmedLine = line.trimmingCharacters(in: .whitespaces)
            
            // Parse module lines (format: "exploit/windows/browser/adobe_flash_hacking_team_uaf   2015-07-14   normal  ...")
            if trimmedLine.hasPrefix("exploit/") || trimmedLine.hasPrefix("auxiliary/") || trimmedLine.hasPrefix("post/") {
                let components = trimmedLine.components(separatedBy: .whitespaces).filter { !$0.isEmpty }
                
                if components.count >= 3 {
                    let moduleName = components[0]
                    
                    modules.append(MetasploitModule(
                        name: moduleName,
                        fullName: moduleName,
                        cveId: extractCVEFromModuleName(moduleName),
                        description: components.dropFirst(3).joined(separator: " "),
                        rank: mapMetasploitRank(components.count > 2 ? components[2] : "normal"),
                        targets: ["Windows"], // Basic default
                        payloads: [], // Empty for now
                        difficulty: .medium, // Default difficulty
                        category: mapModuleCategory(moduleName),
                        lastUpdate: Date(),
                        isReliable: true
                    ))
                }
            }
        }
        
        return modules
    }
    
    private func mapMetasploitRank(_ rankString: String) -> MetasploitModule.ExploitRank {
        switch rankString.lowercased() {
        case "excellent": return .excellent
        case "great": return .great
        case "good": return .good
        case "normal": return .normal
        case "average": return .average
        case "low": return .low
        case "manual": return .manual
        default: return .normal
        }
    }
    
    private func mapModuleCategory(_ moduleName: String) -> MetasploitModule.ModuleCategory {
        if moduleName.hasPrefix("exploit/") { return .exploit }
        if moduleName.hasPrefix("auxiliary/") { return .auxiliary }
        if moduleName.hasPrefix("post/") { return .post }
        if moduleName.hasPrefix("payload/") { return .payload }
        if moduleName.hasPrefix("encoder/") { return .encoder }
        if moduleName.hasPrefix("nop/") { return .nop }
        return .exploit
    }
    
    private func extractCVEFromModuleName(_ moduleName: String) -> String? {
        let pattern = "cve[_-](\\d{4})[_-](\\d{4,7})"
        if let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive) {
            let range = NSRange(moduleName.startIndex..., in: moduleName)
            if let match = regex.firstMatch(in: moduleName, range: range) {
                let year = String(moduleName[Range(match.range(at: 1), in: moduleName)!])
                let id = String(moduleName[Range(match.range(at: 2), in: moduleName)!])
                return "CVE-\(year)-\(id)"
            }
        }
        return nil
    }
    
    private func findMetasploitPath() -> String? {
        let searchPaths = [
            "/opt/homebrew/bin/msfconsole",
            "/usr/local/bin/msfconsole",
            "/usr/bin/msfconsole",
            "/opt/metasploit-framework/bin/msfconsole"
        ]
        
        for path in searchPaths {
            if FileManager.default.fileExists(atPath: path) {
                return path
            }
        }
        return nil
    }
    
    // MARK: - Helper Methods
    
    private func findSearchsploitPath() -> String? {
        let searchPaths = [
            "/opt/homebrew/bin/searchsploit",
            "/usr/local/bin/searchsploit",
            "/usr/bin/searchsploit"
        ]
        
        for path in searchPaths {
            if FileManager.default.fileExists(atPath: path) {
                return path
            }
        }
        return nil
    }
    
    private func extractCVEFromTitle(_ title: String) -> String? {
        let pattern = "CVE-\\d{4}-\\d{4,7}"
        if let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive) {
            let range = NSRange(title.startIndex..., in: title)
            if let match = regex.firstMatch(in: title, range: range) {
                return String(title[Range(match.range, in: title)!])
            }
        }
        return nil
    }
    
    private func mapExploitType(_ type: String) -> ExploitType {
        switch type.lowercased() {
        case "remote": return .remote
        case "local": return .local
        case "webapps", "web": return .webApp
        case "dos": return .dos
        default: return .remote
        }
    }
    
    private func loadStoredAPIKeys() {
        // Load from UserDefaults or Keychain
        nvdAPIKey = UserDefaults.standard.string(forKey: "nvdAPIKey") ?? ""
        shodanAPIKey = UserDefaults.standard.string(forKey: "shodanAPIKey") ?? ""
    }
    
    func saveAPIKey(_ key: String, for service: String) {
        UserDefaults.standard.set(key, forKey: "\(service)APIKey")
        
        switch service {
        case "nvd": nvdAPIKey = key
        case "shodan": shodanAPIKey = key
        default: break
        }
    }
}

// MARK: - Component Views

struct CVECard: View {
    let cve: CVEEntry
    let onSearchExploits: () -> Void
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Text(cve.id)
                    .font(.headline)
                
                Spacer()
                
                Text(String(format: "%.1f", cve.cvssScore))
                    .font(.title3)
                    .fontWeight(.bold)
                    .foregroundColor(cve.severity.color)
                
                Text(cve.severity.rawValue)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(cve.severity.color.opacity(0.2))
                    .cornerRadius(4)
            }
            
            Text(cve.description)
                .font(.caption)
                .lineLimit(3)
                .foregroundColor(.secondary)
            
            HStack {
                Button("Search Exploits") {
                    onSearchExploits()
                }
                .buttonStyle(.link)
                .font(.caption)
                
                Spacer()
                
                Text(cve.publishedDate, style: .date)
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .background(Color.gray.opacity(0.05))
        .cornerRadius(8)
    }
}

struct ExploitCard: View {
    let exploit: ExploitEntry
    let onDownload: () -> Void
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                VStack(alignment: .leading) {
                    Text(exploit.title)
                        .font(.headline)
                        .lineLimit(2)
                    
                    Text("by \(exploit.author)")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                
                Spacer()
                
                Text("EDB-\(exploit.id)")
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(Color.blue.opacity(0.2))
                    .cornerRadius(4)
            }
            
            HStack {
                Text(exploit.platform)
                    .font(.caption2)
                    .padding(.horizontal, 6)
                    .padding(.vertical, 2)
                    .background(Color.gray.opacity(0.2))
                    .cornerRadius(4)
                
                Text(exploit.type)
                    .font(.caption2)
                    .padding(.horizontal, 6)
                    .padding(.vertical, 2)
                    .background(Color.orange.opacity(0.2))
                    .cornerRadius(4)
                
                Spacer()
                
                Button("Download") {
                    onDownload()
                }
                .buttonStyle(.bordered)
                .controlSize(.small)
            }
        }
        .padding()
        .background(Color.gray.opacity(0.05))
        .cornerRadius(8)
    }
}

struct MetasploitModuleCard: View {
    let module: MetasploitModule
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Text(module.name)
                    .font(.headline)
                
                Spacer()
                
                Text(module.rank.rawValue)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(module.rank.color.opacity(0.2))
                    .cornerRadius(4)
            }
            
            Text(module.description)
                .font(.caption)
                .lineLimit(2)
                .foregroundColor(.secondary)
            
            HStack {
                if let cveId = module.cveId {
                    Text(cveId)
                        .font(.caption2)
                        .padding(.horizontal, 6)
                        .padding(.vertical, 2)
                        .background(Color.blue.opacity(0.2))
                        .cornerRadius(4)
                }
                
                Text(module.category.rawValue)
                    .font(.caption2)
                    .padding(.horizontal, 6)
                    .padding(.vertical, 2)
                    .background(Color.gray.opacity(0.2))
                    .cornerRadius(4)
                
                Spacer()
            }
        }
        .padding()
        .background(Color.gray.opacity(0.05))
        .cornerRadius(8)
    }
}

// MARK: - API Settings View

struct APISettingsView: View {
    @Environment(\.dismiss) private var dismiss
    @ObservedObject var viewModel: ExploitDatabaseViewModel
    
    @State private var nvdKey = ""
    @State private var shodanKey = ""
    @State private var virustotalKey = ""
    
    var body: some View {
        VStack(spacing: 20) {
            Text("API Configuration")
                .font(.title2)
                .fontWeight(.bold)
            
            Form {
                Section(header: Text("National Vulnerability Database")) {
                    TextField("NVD API Key (optional)", text: $nvdKey)
                    Text("Get your free API key at https://nvd.nist.gov/developers/request-an-api-key")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                
                Section(header: Text("Shodan")) {
                    TextField("Shodan API Key", text: $shodanKey)
                    Text("Get your API key at https://shodan.io/account")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                
                Section(header: Text("VirusTotal")) {
                    TextField("VirusTotal API Key", text: $virustotalKey)
                    Text("Get your API key at https://www.virustotal.com/gui/my-apikey")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
            .frame(width: 500, height: 300)
            
            HStack {
                Button("Cancel") {
                    dismiss()
                }
                
                Spacer()
                
                Button("Save") {
                    saveKeys()
                    dismiss()
                }
                .buttonStyle(.borderedProminent)
            }
            .padding()
        }
        .padding()
    }
    
    private func saveKeys() {
        if !nvdKey.isEmpty {
            viewModel.saveAPIKey(nvdKey, for: "nvd")
        }
        if !shodanKey.isEmpty {
            viewModel.saveAPIKey(shodanKey, for: "shodan")
        }
        if !virustotalKey.isEmpty {
            viewModel.saveAPIKey(virustotalKey, for: "virustotal")
        }
    }
}

#Preview {
    AdvancedExploitDatabaseView()
}